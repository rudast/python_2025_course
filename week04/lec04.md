# TDD - test driven development

Какие бывают виды тестов:

* Unit - проверка наименьшей атомарной единицы. Пример, тесты на отдельные функции в классе ```Math_op``` и в классе ```Numpy```
* integration - тестируется взаимодействие нескольких юнитов. Начиная с нескольких классов и заканчивая микросервисами.
* E2E - тестирование целого законченного сервиса.


[inference server(with LLM)] <--->  [back ] <---> [web/app ]




Стратегии тестирования кода
- белый ящик
    - доступ к коду
    - знание структуры вцелом
    - фокус на внутренней логике
- серый
- черный ящик
    - отсутствует доступ к коду и не известна структура
    - фокус на функциональных требованиях (управления входными и выходными данными)
    - имитация поведения пользователя




Пирамидка Маслоу в тестирвании

E2E

"____"

Integration test

"__________"

Unit

"_________________"


Метрики покрытия кода тестами


Code Coverage

Code coverage = ( Кол-во выполненных строк кода при тестировании) / (Общее кол-во строк кода)

Branch Coverage = Кол-во покрытых ветвей кода / К общему кол-ву



# Unit tests


##  Характеристики хорошего Unit test:

* легкость запуска (одна команда или одна кнопка)
* детерминированный (выдает один и тот же результат)

* тест должен быть понятным
    * название читаемое и осмысленное (информативное)
    * хорошо структурированы (кода)
    * хорошо структурированы (логов)
    * легкость поддержки и дальнейшего развития
* эффективный
    * покрытие всех возможных варантов
    * сфокусированный
        * проверяет одну конкретную задачу
        * если упал тест, то сразу понятно в чем проблема падения
    * быстрый

    * скорость написания
        * отсутствие дублирования кода
        * легкость поддержки и дальнейшего развития


## Best practices

1. Секции AAA  в единственном числе

```
def test_get_player_score():
    # входные данные - arrange
    # действие - act
    # проверка результата - assert

def test_get_player_score2():

    # входные данные2 - arrange
    # действие2 - act
    # проверка результата 2- assert

def test_get_player_score3():
    # входные данные2 - arrange
    # действие2 - act

    # действие 3 - act
    # проверка результата 3- assert <--

```
2. Отсутствие if
        Хочешь вставить if - пиши еще один юнит тест

3. Подготовку данных и общие действия автоматизировать (fixtures)

4. Параметризацию тестов


# Защита от багов

- объем кода который проверяется тестом
- сложность этого кода
- busines value


Код который содержит важную бизнес логику - сильно важнее чем например инфраструктурный код





```python
class Math_op:

    def foo1(a:int, b: int) -> float:
        return a / b

    def foo2_mul():
        pass
```


```python
class Numpy:
    def foo_mat_mul(mat1, mat2):
        pass

```


```python


def test_get_player_score():
    # входные данные - arrange
    # действие - act
    # проверка результата - assert



def <unit>_<actor>_<result>():
    pass

def <act>_<arrange>_<assert>():
    pass

```
